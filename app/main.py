# =================================================
# STREAMLIT CLOUD IMPORT FIX (MUST BE FIRST)
# =================================================
import os
import sys

PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
sys.path.insert(0, PROJECT_ROOT)

# =================================================
# STANDARD IMPORTS
# =================================================
import streamlit as st

# -----------------------------
# Data layer
# -----------------------------
from data.router.price_router import (
    get_sol_price,
    get_sol_price_history
)

# -----------------------------
# Strategy engines
# -----------------------------
from core.strategy.fusion_engine import fuse_signals
from core.strategy.range_engine import generate_range_and_liquidation
from core.fa.fa_aggregator import aggregate_fa_signals


# =================================================
# STREAMLIT UI
# =================================================
st.set_page_config(
    page_title="DefiTuna LP Dashboard",
    layout="wide"
)

st.title("DefiTuna LP Dashboard")
st.caption("Auto Liquidity Intelligence System ‚Ä¢ LP-first ‚Ä¢ Risk-aware")

# -----------------------------
# Fetch price data
# -----------------------------
with st.spinner("Fetching live SOL price..."):
    current_price = get_sol_price()
    price_history = get_sol_price_history(days=200)

if current_price is None or price_history is None:
    st.error("Unable to fetch SOL price data.")
    st.stop()

# -----------------------------
# Run engines
# -----------------------------
fusion_output = fuse_signals(price_history)

range_output = generate_range_and_liquidation(
    current_price=current_price,
    fusion_output=fusion_output
)

fa_output = aggregate_fa_signals()

# -----------------------------
# SECTION 1: Live Price
# -----------------------------
st.markdown("## üîµ Live Solana (SOL) Price")
st.metric("SOL Price (USD)", f"${current_price:,.2f}")

# -----------------------------
# SECTION 2: Directional Bias
# -----------------------------
st.markdown("## üìà Directional Bias")
st.write(f"**Direction:** {fusion_output['final_direction']}")
st.write(f"**Risk Mode:** {fusion_output['risk_mode']}")
st.write(f"**Confidence:** {fusion_output['final_confidence']}")

# -----------------------------
# SECTION 3: Auto Liquidity Range
# -----------------------------
st.markdown("## üìä Autogenerated Liquidity Range")

c1, c2, c3 = st.columns(3)
c1.metric("Range Low", f"${range_output['range_low']}")
c2.metric("Range High", f"${range_output['range_high']}")
c3.metric("Range Width (%)", f"{range_output['range_width_pct']}%")

st.write(f"**Position Mode:** {range_output['position_mode']}")

# -----------------------------
# SECTION 4: Risk Levels
# -----------------------------
st.markdown("## ‚ö†Ô∏è Risk Levels")

if range_output["liquidation_level"] is not None:
    st.metric(
        "Liquidation Alert Level",
        f"${range_output['liquidation_level']}"
    )
    st.caption("Directional leverage risk level.")
else:
    c1, c2 = st.columns(2)
    c1.metric("Downside Risk Boundary", f"${range_output['range_low']}")
    c2.metric("Upside Risk Boundary", f"${range_output['range_high']}")
    st.caption("Neutral LP: risk is exiting range, not liquidation.")

# -----------------------------
# SECTION 5: Technical Drivers
# -----------------------------
st.markdown("## üßÆ Key Technical Drivers")
for driver in fusion_output["ta_drivers"]:
    st.write(f"‚Ä¢ {driver}")

# -----------------------------
# SECTION 6: Fundamental Signals
# -----------------------------
st.markdown("## üß† Fundamental Risk Signals")
st.write(f"**FA Bias:** {fa_output['fa_bias']}")
st.write(f"**FA Confidence:** {fa_output['confidence']}")

if fa_output["risk_flags"]:
    st.write("**Active Risk Flags:**")
    for flag in fa_output["risk_flags"]:
        st.write(f"‚Ä¢ {flag}")
else:
    st.write("No active fundamental risk flags.")

# -----------------------------
# SECTION 7: News Feed
# -----------------------------
st.markdown("## üì∞ News Feed")

def render_news(title, items):
    st.subheader(title)
    if not items:
        st.write("No recent items.")
        return
    for n in items[:5]:
        st.markdown(f"- [{n['title']}]({n['link']})")

render_news("ü™ô Crypto News", fa_output.get("crypto_news", []))
render_news("üåç Macro News", fa_output.get("macro_news", []))
render_news("‚ö†Ô∏è Geopolitical Risk", fa_output.get("geopolitical_news", []))

# -----------------------------
# SECTION 8: Explanation
# -----------------------------
st.markdown("## üìù System Explanation")
st.write(range_output["explanation"])
